/**
 * @preserve This generated code and related technologies are covered by patents
 * or patents pending by Appcelerator, Inc.
 *
 * WARNING: this file is generated and will be overwritten
 * It was generated from <%=gen.filename%> on <%=new Date%>
 */
@import JavaScriptCore;
#import <hyperloop.h>
#import "NSException+NSExceptionHyperloopAdditions.h"
<% imports.forEach(function(i) { -%>
@import <%=i%>;
<% }) -%>
<% _includes.forEach(function(i) { -%>
#import <%-i%>
<% }) -%>

// implementations define this
extern NSData* HyperloopDecompressBuffer (NSData*);

<% externs.forEach(function(e) { -%>
<%- e -%>;

<% }) -%>


@interface <%=gen.prefix%><%=gen.name%> : NSObject<HyperloopModule>
+(JSValueRef)load:(JSContextRef)context;
@end

@implementation <%=gen.prefix%><%=gen.name%>

+(NSData*)buffer
{
	static UInt8 data[] = {
		<%=gen.jsBuffer %>
	};
	return [NSData dataWithBytes:((void*)data) length:<%=gen.jsBuffer.length%>];
}

+(JSValueRef)load:(JSContextRef)ctx
{
	@autoreleasepool
	{
		// TODO: currently, we are assigned variables into global scope -- but once we put in require support
		// we need to bind all these variables into the objects scope

		JSObjectRef object = JSContextGetGlobalObject(ctx);

<% Object.keys(memory).forEach(function(key) {
		var mem = memory[key];
-%>
		//
		// @memory -> <%- mem.node.start.file %>:<%- mem.node.start.line %>:<%- mem.node.start.col%>
		//
		// don't free, memory ownership is passed to JSObjectRef (<%=key%>$Object)
		//
		<%- indentify(mem.code,'		') %>

		JSBuffer *<%=key%>$Buffer = malloc(sizeof(JSBuffer));
		<%=key%>$Buffer->type = JSBufferTypePointer;
		<%=key%>$Buffer->buffer = (void*) <%-mem.assign%>;
		<%=key%>$Buffer->length = <%-mem.length%>;

		JSObjectRef <%=key%>$Object = MakeObjectForJSBuffer (ctx, <%=key%>$Buffer);
		JSStringRef <%=key%>$Name = JSStringCreateWithUTF8CString("<%=key%>");
		JSObjectSetProperty(ctx, object, <%=key%>$Name, <%=key%>$Object, kJSPropertyAttributeReadOnly|kJSPropertyAttributeDontEnum|kJSPropertyAttributeDontDelete, 0);
		JSStringRelease(<%=key%>$Name);

<% }) -%>

		<%-indentify(code,'		') %>

		// load up our JS
		NSData *compressedBuf = [<%=gen.prefix%><%=gen.name%> buffer];
		NSString *jscode;
		if ([compressedBuf length]==1)
		{
			// if empty, just evaluate empty JS string
			jscode = @"";
		}
		else
		{
			NSData *buffer = HyperloopDecompressBuffer(compressedBuf);
			jscode = [[[NSString alloc] initWithData:buffer encoding:NSUTF8StringEncoding] autorelease];
		}

		NSString *wrapper = [NSString stringWithFormat:@"var module = {}, exports = {}; module.id = '<%=gen.name%>'; module.exports = exports; %@; return module.exports;",jscode];

		JSStringRef fnName = JSStringCreateWithUTF8CString("require");
		JSStringRef body = JSStringCreateWithUTF8CString([wrapper UTF8String]);
		JSStringRef filenameRef = JSStringCreateWithUTF8CString([@"<%=gen.filename%>" UTF8String]);
		JSObjectRef requireFn = JSObjectMakeFunction(ctx, fnName, 0, 0, body, filenameRef, 0, 0);
		JSStringRelease(fnName);
		JSStringRelease(body);
		JSStringRelease(filenameRef);

		// invoke the common JS wrapper
		JSValueRef exception = NULL;
		JSValueRef result = JSObjectCallAsFunction(ctx, requireFn, object, 0, NULL, &exception);
		CHECK_EXCEPTION(ctx, exception);

		return result;
	}
}

@end
